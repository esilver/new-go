This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
peerapi/
  Dockerfile
  go.mod
  main.go
rendezvous/
  .gitkeep
  build_test.go
  Dockerfile
  go.mod
  main_test.go
  main.go
webdemo/
  index.html
worker/
  .gitkeep
  build_test.go
  Dockerfile
  go.mod
  host_test.go
  main_test.go
  main.go
deploy_cloud_run.sh
deploy_demo_cloud_run.sh
Makefile
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="peerapi/Dockerfile">
# --- Build stage ---
FROM --platform=$BUILDPLATFORM golang:1.24.3-alpine AS builder
RUN apk add --no-cache git
WORKDIR /app
COPY . ./
RUN go mod tidy && go mod download && \
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath -o peerapi .

# --- Runtime stage ---
FROM gcr.io/distroless/static-debian11
WORKDIR /app
COPY --from=builder /app/peerapi .
EXPOSE 8080
ENTRYPOINT ["/app/peerapi"]
</file>

<file path="peerapi/go.mod">
module github.com/yourusername/peerapi

go 1.24.3
</file>

<file path="peerapi/main.go">
package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"
)

// peersMap stores peerID -> multiaddr (as string).
// This service keeps everything in memory â€“ fine for demos.
var peersMap = make(map[string]string)
var peersMu sync.RWMutex

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}

	mux := http.NewServeMux()

	mux.HandleFunc("/peers", func(w http.ResponseWriter, r *http.Request) {
		switch r.Method {
		case http.MethodGet:
			peersMu.RLock()
			defer peersMu.RUnlock()
			w.Header().Set("Content-Type", "application/json")
			_ = json.NewEncoder(w).Encode(peersMap)
		case http.MethodPost:
			var payload struct {
				ID   string `json:"id"`
				Addr string `json:"addr"`
			}
			if err := json.NewDecoder(r.Body).Decode(&payload); err != nil {
				http.Error(w, "bad JSON", http.StatusBadRequest)
				return
			}
			if payload.ID == "" || payload.Addr == "" {
				http.Error(w, "id and addr required", http.StatusBadRequest)
				return
			}
			peersMu.Lock()
			peersMap[payload.ID] = payload.Addr
			peersMu.Unlock()
			w.WriteHeader(http.StatusNoContent)
		default:
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
		}
	})

	mux.HandleFunc("/peers/", func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodDelete {
			http.Error(w, "method not allowed", http.StatusMethodNotAllowed)
			return
		}
		id := strings.TrimPrefix(r.URL.Path, "/peers/")
		if id == "" {
			http.Error(w, "missing id", http.StatusBadRequest)
			return
		}
		peersMu.Lock()
		delete(peersMap, id)
		peersMu.Unlock()
		w.WriteHeader(http.StatusNoContent)
	})

	addr := ":" + port
	log.Printf("Peer discovery API listening on %s (endpoints: GET/POST /peers, DELETE /peers/{id})", addr)
	if err := http.ListenAndServe(addr, mux); err != nil {
		log.Fatalf("server error: %v", err)
	}
}
</file>

<file path="rendezvous/.gitkeep">

</file>

<file path="rendezvous/build_test.go">
package main

import (
    "os/exec"
    "testing"
)

// TestBinaryBuild ensures the rendezvous service builds without errors. This is a guard
// for Docker image builds (which also run `go build`).
func TestBinaryBuild(t *testing.T) {
    cmd := exec.Command("go", "build", "-o", "build-test-bin", ".")
    if out, err := cmd.CombinedOutput(); err != nil {
        t.Fatalf("go build failed: %v\n%s", err, string(out))
    }
}
</file>

<file path="rendezvous/Dockerfile">
# --- Build stage ---
FROM --platform=$BUILDPLATFORM golang:1.24.3-alpine AS builder
RUN apk add --no-cache git
WORKDIR /app
COPY . ./
# compile static binary for linux/amd64
RUN go mod tidy && go mod download && \
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath -o rendezvous .

# --- Runtime stage ---
FROM gcr.io/distroless/static-debian11
WORKDIR /app
COPY --from=builder /app/rendezvous .
EXPOSE 8080
ENTRYPOINT ["/app/rendezvous"]
</file>

<file path="rendezvous/go.mod">
module github.com/yourusername/rendezvous

go 1.24.3

require (
	github.com/libp2p/go-libp2p v0.41.1
	github.com/multiformats/go-multiaddr v0.15.0
	github.com/soheilhy/cmux v0.1.5
	github.com/stretchr/testify v1.10.0
)

require (
	github.com/benbjohnson/clock v1.3.5 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/containerd/cgroups v1.1.0 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/davidlazar/go-crypto v0.0.0-20200604182044-b73af7476f6c // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/elastic/gosigar v0.14.3 // indirect
	github.com/flynn/noise v1.1.0 // indirect
	github.com/francoispqt/gojay v1.2.13 // indirect
	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/gopacket v1.1.19 // indirect
	github.com/google/pprof v0.0.0-20250208200701-d0013a598941 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/huin/goupnp v1.3.0 // indirect
	github.com/ipfs/go-cid v0.5.0 // indirect
	github.com/ipfs/go-log/v2 v2.5.1 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2 // indirect
	github.com/jbenet/go-temp-err-catcher v0.1.0 // indirect
	github.com/klauspost/compress v1.18.0 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/koron/go-ssdp v0.0.5 // indirect
	github.com/libp2p/go-buffer-pool v0.1.0 // indirect
	github.com/libp2p/go-flow-metrics v0.2.0 // indirect
	github.com/libp2p/go-libp2p-asn-util v0.4.1 // indirect
	github.com/libp2p/go-msgio v0.3.0 // indirect
	github.com/libp2p/go-netroute v0.2.2 // indirect
	github.com/libp2p/go-reuseport v0.4.0 // indirect
	github.com/libp2p/go-yamux/v5 v5.0.0 // indirect
	github.com/marten-seemann/tcp v0.0.0-20210406111302-dfbc87cc63fd // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/miekg/dns v1.1.63 // indirect
	github.com/mikioh/tcpinfo v0.0.0-20190314235526-30a79bb1804b // indirect
	github.com/mikioh/tcpopt v0.0.0-20190314235656-172688c1accc // indirect
	github.com/minio/sha256-simd v1.0.1 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.1.0 // indirect
	github.com/multiformats/go-base36 v0.2.0 // indirect
	github.com/multiformats/go-multiaddr-dns v0.4.1 // indirect
	github.com/multiformats/go-multiaddr-fmt v0.1.0 // indirect
	github.com/multiformats/go-multibase v0.2.0 // indirect
	github.com/multiformats/go-multicodec v0.9.0 // indirect
	github.com/multiformats/go-multihash v0.2.3 // indirect
	github.com/multiformats/go-multistream v0.6.0 // indirect
	github.com/multiformats/go-varint v0.0.7 // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/onsi/ginkgo/v2 v2.22.2 // indirect
	github.com/opencontainers/runtime-spec v1.2.0 // indirect
	github.com/pbnjay/memory v0.0.0-20210728143218-7b4eea64cf58 // indirect
	github.com/pion/datachannel v1.5.10 // indirect
	github.com/pion/dtls/v2 v2.2.12 // indirect
	github.com/pion/dtls/v3 v3.0.4 // indirect
	github.com/pion/ice/v4 v4.0.8 // indirect
	github.com/pion/interceptor v0.1.37 // indirect
	github.com/pion/logging v0.2.3 // indirect
	github.com/pion/mdns/v2 v2.0.7 // indirect
	github.com/pion/randutil v0.1.0 // indirect
	github.com/pion/rtcp v1.2.15 // indirect
	github.com/pion/rtp v1.8.11 // indirect
	github.com/pion/sctp v1.8.37 // indirect
	github.com/pion/sdp/v3 v3.0.10 // indirect
	github.com/pion/srtp/v3 v3.0.4 // indirect
	github.com/pion/stun v0.6.1 // indirect
	github.com/pion/stun/v3 v3.0.0 // indirect
	github.com/pion/transport/v2 v2.2.10 // indirect
	github.com/pion/transport/v3 v3.0.7 // indirect
	github.com/pion/turn/v4 v4.0.0 // indirect
	github.com/pion/webrtc/v4 v4.0.10 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/prometheus/client_golang v1.21.1 // indirect
	github.com/prometheus/client_model v0.6.1 // indirect
	github.com/prometheus/common v0.62.0 // indirect
	github.com/prometheus/procfs v0.15.1 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.50.1 // indirect
	github.com/quic-go/webtransport-go v0.8.1-0.20241018022711-4ac2c9250e66 // indirect
	github.com/raulk/go-watchdog v1.3.0 // indirect
	github.com/spaolacci/murmur3 v1.1.0 // indirect
	github.com/wlynxg/anet v0.0.5 // indirect
	go.uber.org/dig v1.18.0 // indirect
	go.uber.org/fx v1.23.0 // indirect
	go.uber.org/mock v0.5.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
	golang.org/x/crypto v0.35.0 // indirect
	golang.org/x/exp v0.0.0-20250218142911-aa4b98e5adaa // indirect
	golang.org/x/mod v0.23.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	golang.org/x/tools v0.30.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	lukechampine.com/blake3 v1.4.0 // indirect
)
</file>

<file path="rendezvous/main_test.go">
package main

import (
	"context"
	"fmt"
	"io"
	"strings"
	"testing"
	"time"

	libp2p "github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	ma "github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
)

func TestCreateLibp2pHost(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Use port 0 to let the OS pick a free port for testing.
	h, err := createHost(ctx, 0)
	require.NoError(t, err, "Failed to create libp2p host")
	require.NotNil(t, h, "Created host should not be nil")

	t.Logf("Successfully created host with ID: %s", h.ID())
	t.Logf("Host listening on addresses: %v", h.Addrs())
	require.NotEmpty(t, h.Addrs(), "Host should be listening on at least one address")

	err = h.Close()
	require.NoError(t, err, "Failed to close host")
}

// Store for registered peers in tests. In main.go, this would be part of the server state.
var (
	testRegisteredPeers = make(map[peer.ID]ma.Multiaddr)
)

// simpleRegistrationHandlerForTest is a basic stream handler for testing purposes.
// It reads a message (expected to be the worker's listen address, or an empty message for simplicity) and stores the remote peer's info.
func simpleRegistrationHandlerForTest(s network.Stream) {
	defer s.Close()
	remotePeerID := s.Conn().RemotePeer()
	remoteAddr := s.Conn().RemoteMultiaddr()

	testRegisteredPeers[remotePeerID] = remoteAddr // Storing the observed address from the connection
	fmt.Printf("[Test Handler] Registered peer %s with address %s\n", remotePeerID, remoteAddr)

	// Optionally, read a message from the worker if the protocol defines one.
	// For now, just establishing the stream is enough for registration.
	// buf := make([]byte, 256)
	// n, err := s.Read(buf)
	// if err != nil && err != io.EOF {
	// 	fmt.Printf("[Test Handler] Error reading from stream: %v\n", err)
	// 	return
	// }
	// fmt.Printf("[Test Handler] Received message from %s: %s\n", remotePeerID, string(buf[:n]))

	// Send a simple ack
	_, err := s.Write([]byte("ACK"))
	if err != nil {
		fmt.Printf("[Test Handler] Error writing ACK: %v\n", err)
	}
}

func TestWorkerRegistersWithRendezvous(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// 1. Create Rendezvous Host (Server)
	rendezvousHost, err := createHost(ctx, 0)
	require.NoError(t, err, "Failed to create rendezvous host")
	defer rendezvousHost.Close()

	t.Logf("Rendezvous host created with ID: %s, Addrs: %v", rendezvousHost.ID(), rendezvousHost.Addrs())

	// Reset test store for this test
	testRegisteredPeers = make(map[peer.ID]ma.Multiaddr)
	// Set the stream handler on the rendezvous host
	rendezvousHost.SetStreamHandler(ProtocolIDForRegistration, simpleRegistrationHandlerForTest)

	// 2. Create Worker Host (Client)
	// For the worker host, we use createHost from main.go for simplicity in testing.
	workerHost, err := createHost(ctx, 0)
	require.NoError(t, err, "Failed to create worker host")
	defer workerHost.Close()
	t.Logf("Worker host created with ID: %s, Addrs: %v", workerHost.ID(), workerHost.Addrs())

	// 3. Worker Connects to Rendezvous Host
	rendezvousAddrInfo := peer.AddrInfo{
		ID:    rendezvousHost.ID(),
		Addrs: rendezvousHost.Addrs(),
	}
	err = workerHost.Connect(ctx, rendezvousAddrInfo)
	require.NoError(t, err, "Worker failed to connect to rendezvous host")
	t.Logf("Worker successfully connected to rendezvous host.")

	// 4. Worker Opens a New Stream for Registration
	stream, err := workerHost.NewStream(ctx, rendezvousHost.ID(), ProtocolIDForRegistration)
	require.NoError(t, err, "Worker failed to open new stream to rendezvous host")
	t.Logf("Worker opened registration stream to rendezvous host.")

	// Optionally, worker sends some data (e.g., its listen addrs or a specific registration payload)
	// For this test, establishing the stream might be enough, and the handler uses the connection's remote addr.
	// _, err = stream.Write([]byte("Hello from worker"))
	// require.NoError(t, err, "Worker failed to write to stream")

	// Wait for ACK or for handler to process
	ackBuf := make([]byte, 3)
	_, err = stream.Read(ackBuf)
	require.NoError(t, err, "Worker failed to read ACK from rendezvous")
	require.Equal(t, "ACK", string(ackBuf), "Worker did not receive correct ACK")
	t.Logf("Worker received ACK from rendezvous.")

	stream.Close() // Close the stream from the worker side

	// 5. Verify Rendezvous Service Recorded the Worker
	// Allow some time for the handler to execute, though with direct connect it should be quick.
	// For more robust checks, might need a channel or wait group if handler is more complex.
	_, ok := testRegisteredPeers[workerHost.ID()]
	require.True(t, ok, "Rendezvous service did not register the worker host ID")
	// We can also check if the address stored is one of the worker's, but the remote multiaddr
	// from the connection (s.Conn().RemoteMultiaddr()) will be the one seen by the rendezvous host.
	t.Logf("Successfully verified that rendezvous service registered worker %s with addr %s", workerHost.ID(), testRegisteredPeers[workerHost.ID()])
}

func TestRendezvousServiceRuns(t *testing.T) {
	// This is a placeholder test.
	// In a real scenario, we'd start the service and check its status.
	t.Log("Placeholder test for rendezvous service. Needs actual implementation.")
	// For now, we can try to build and run the main func if it's simple enough,
	// but a proper test would involve more.
	if false { // Keep this false until main() is testable
		go main()
		// Add assertions here if main() was to run and exit cleanly for a test.
	}
}

// TestCreateHostIncludesWebsocket ensures createHost publishes at least one
// listen address that contains the `/ws` WebSocket component.
func TestCreateHostIncludesWebsocket(t *testing.T) {
	ctx := context.Background()
	h, err := createHost(ctx, 0) // random free port
	if err != nil {
		t.Fatalf("createHost returned error: %v", err)
	}
	defer h.Close()

	foundWS := false
	for _, addr := range h.Addrs() {
		if strings.Contains(addr.String(), "/ws") {
			foundWS = true
			break
		}
	}
	if !foundWS {
		t.Fatalf("expected at least one /ws address, got %v", h.Addrs())
	}
}

// TestWorkerRegistration end-to-end: spin up a rendezvous host, a worker host,
// have the worker connect & register, and assert we receive the "ACK".
func TestWorkerRegistration(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Rendezvous host
	rendezvousHost, err := createHost(ctx, 0)
	if err != nil {
		t.Fatalf("createHost (rendezvous) error: %v", err)
	}
	defer rendezvousHost.Close()
	rendezvousHost.SetStreamHandler(ProtocolIDForRegistration, simpleRegistrationHandlerForTest)

	// Worker host
	workerHost, err := libp2p.New()
	if err != nil {
		t.Fatalf("worker host creation error: %v", err)
	}
	defer workerHost.Close()

	// Build full multiaddr for rendezvous host (we'll just pick the first addr).
	if len(rendezvousHost.Addrs()) == 0 {
		t.Fatal("rendezvous host has no listen addresses")
	}
	baseAddr := rendezvousHost.Addrs()[0]
	fullAddr := baseAddr.Encapsulate(ma.StringCast("/p2p/" + rendezvousHost.ID().String()))
	addrInfo, err := peer.AddrInfoFromP2pAddr(fullAddr)
	if err != nil {
		t.Fatalf("AddrInfoFromP2pAddr error: %v", err)
	}

	// Connect worker -> rendezvous
	if err := workerHost.Connect(ctx, *addrInfo); err != nil {
		t.Fatalf("worker connect error: %v", err)
	}

	// Open registration stream
	stream, err := workerHost.NewStream(ctx, rendezvousHost.ID(), ProtocolIDForRegistration)
	if err != nil {
		t.Fatalf("open stream error: %v", err)
	}
	defer stream.Close()

	// Read ACK (3 bytes)
	ack := make([]byte, 3)
	if _, err := io.ReadFull(stream, ack); err != nil {
		t.Fatalf("reading ACK failed: %v", err)
	}
	if string(ack) != "ACK" {
		t.Fatalf("unexpected ACK payload: %q", string(ack))
	}
}

// TestListProtocolReturnsPeers verifies that the listHandler sends registered peers.
func TestListProtocolReturnsPeers(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	defer cancel()

	// Rendezvous host
	rvHost, err := createHost(ctx, 0)
	require.NoError(t, err)
	defer rvHost.Close()
	rvHost.SetStreamHandler(ProtocolIDForRegistration, registrationHandler)
	rvHost.SetStreamHandler(ProtocolIDForPeerList, listHandler)

	// worker1
	w1, err := libp2p.New()
	require.NoError(t, err)
	defer w1.Close()

	// worker2
	w2, err := libp2p.New()
	require.NoError(t, err)
	defer w2.Close()

	rvInfo := peer.AddrInfo{ID: rvHost.ID(), Addrs: rvHost.Addrs()}
	require.NoError(t, w1.Connect(ctx, rvInfo))
	s, err := w1.NewStream(ctx, rvHost.ID(), ProtocolIDForRegistration)
	require.NoError(t, err)
	io.ReadFull(s, make([]byte, 3))
	s.Close()

	require.NoError(t, w2.Connect(ctx, rvInfo))
	s2, err := w2.NewStream(ctx, rvHost.ID(), ProtocolIDForRegistration)
	require.NoError(t, err)
	io.ReadFull(s2, make([]byte, 3))
	s2.Close()

	// w1 requests list
	listStream, err := w1.NewStream(ctx, rvHost.ID(), ProtocolIDForPeerList)
	require.NoError(t, err)
	data, err := io.ReadAll(listStream)
	require.NoError(t, err)
	listStream.Close()

	lines := strings.Split(strings.TrimSpace(string(data)), "\n")
	require.GreaterOrEqual(t, len(lines), 1)
	found := false
	for _, l := range lines {
		if strings.Contains(l, w2.ID().String()) {
			found = true
		}
	}
	require.True(t, found, "expected w2 in peer list")
}
</file>

<file path="rendezvous/main.go">
package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	ws "github.com/libp2p/go-libp2p/p2p/transport/websocket"
	ma "github.com/multiformats/go-multiaddr"
)

// DefaultPort for the rendezvous service to listen on.
const DefaultPort = 40001

// ProtocolIDForRegistration is the libp2p protocol ID used by workers to register.
const ProtocolIDForRegistration = "/holepunch/rendezvous/1.0.0"

// ProtocolIDForPeerList defines the protocol workers use to request
// a list of currently registered peers.
const ProtocolIDForPeerList = "/holepunch/list/1.0.0"

// registeredPeers stores the PeerID and last known public Multiaddr of registered workers.
// This is a simple in-memory store, not suitable for production without persistence and proper synchronization.
var registeredPeers = make(map[peer.ID]ma.Multiaddr)
var registeredPeersMutex = &sync.Mutex{}

// registrationHandler is called when a worker connects using ProtocolIDForRegistration.
func registrationHandler(s network.Stream) {
	remotePeerID := s.Conn().RemotePeer()
	remoteAddr := s.Conn().RemoteMultiaddr()

	fmt.Printf("Rendezvous: Received registration stream from %s (%s)\n", remotePeerID, remoteAddr)

	registeredPeersMutex.Lock()
	registeredPeers[remotePeerID] = remoteAddr
	registeredPeersMutex.Unlock()

	fmt.Printf("Rendezvous: Worker %s registered with address %s. Total registered: %d\n", remotePeerID, remoteAddr, len(registeredPeers))

	// If a peer discovery service URL is set, forward this registration.
	if peerAPI := os.Getenv("PEER_DISCOVERY_URL"); peerAPI != "" {
		payload := map[string]string{"id": remotePeerID.String(), "addr": remoteAddr.String()}
		if data, err := json.Marshal(payload); err == nil {
			_, err := http.Post(fmt.Sprintf("%s/peers", peerAPI), "application/json", bytes.NewReader(data))
			if err != nil {
				fmt.Printf("Rendezvous: Failed to replicate to discovery API: %v\n", err)
			}
		}
	}

	// Optional: Read any data sent by the worker on this stream.
	// For example, the worker might send its list of listen addresses.
	// buf := make([]byte, 1024)
	// n, err := s.Read(buf)
	// if err != nil && err != io.EOF {
	// 	fmt.Printf("Rendezvous: Error reading from registration stream for %s: %v\n", remotePeerID, err)
	// 	s.Reset() // Reset the stream on error
	// 	return
	// }
	// if n > 0 {
	// 	fmt.Printf("Rendezvous: Received payload from %s: %s\n", remotePeerID, string(buf[:n]))
	// 	// TODO: Process payload, e.g., update stored addresses for the peer.
	// }

	// Send an acknowledgment back to the worker.
	_, err := s.Write([]byte("ACK"))
	if err != nil {
		fmt.Printf("Rendezvous: Error writing ACK to %s: %v\n", remotePeerID, err)
		s.Reset()
		return
	}

	// It's good practice to close the stream when done if the protocol is request-response.
	// However, if the stream is meant to be kept alive for other purposes (like presence), don't close it here.
	// For a simple registration, closing after ACK is fine.
	if err := s.Close(); err != nil {
		fmt.Printf("Rendezvous: Error closing stream for %s: %v\n", remotePeerID, err)
	}
	fmt.Printf("Rendezvous: Registration for %s complete. Stream closed.\n", remotePeerID)
}

// listHandler writes the list of currently registered peers to the requester.
// Each line is a full multiaddr including the peer ID. The requesting peer is
// omitted from the list.
func listHandler(s network.Stream) {
	defer s.Close()

	requester := s.Conn().RemotePeer()
	registeredPeersMutex.Lock()
	defer registeredPeersMutex.Unlock()

	for pid, addr := range registeredPeers {
		if pid == requester {
			continue
		}
		full, err := ma.NewMultiaddr(fmt.Sprintf("%s/p2p/%s", addr.String(), pid.String()))
		if err != nil {
			continue
		}
		_, _ = s.Write([]byte(full.String() + "\n"))
	}
}

// createHost is a helper function that can be used in main.go and for testing.
// It creates a new libp2p host with a default set of options.
func createHost(ctx context.Context, listenPort int) (host.Host, error) {
	// Listen on TCP and WebSocket on the same port (Cloud Run gives us only one).
	tcpAddr := fmt.Sprintf("/ip4/0.0.0.0/tcp/%d", listenPort)
	wsAddr := fmt.Sprintf("/ip4/0.0.0.0/tcp/%d/ws", listenPort)

	h, err := libp2p.New(
		libp2p.ListenAddrStrings(tcpAddr, wsAddr),
		libp2p.Transport(ws.New),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create libp2p host: %w", err)
	}
	return h, nil
}

func main() {
	port := DefaultPort
	if pStr := os.Getenv("PORT"); pStr != "" {
		if p, err := strconv.Atoi(pStr); err == nil {
			port = p
		}
	}
	fmt.Printf("Rendezvous service starting... Listening on port %d\n", port)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	h, err := createHost(ctx, port)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating host: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Host created with ID: %s\n", h.ID().String())
	fmt.Println("Listening on addresses:")
	for _, addr := range h.Addrs() {
		fmt.Printf("  %s/p2p/%s\n", addr, h.ID().String())
	}

	// Set the stream handlers for worker registrations and peer listing
	h.SetStreamHandler(ProtocolIDForRegistration, registrationHandler)
	h.SetStreamHandler(ProtocolIDForPeerList, listHandler)
	fmt.Printf("Set stream handler for protocol: %s\n", ProtocolIDForRegistration)
	fmt.Printf("Set stream handler for protocol: %s\n", ProtocolIDForPeerList)

	// -------------------------------------------------------------------
	// HTTP Peer-Discovery API
	// -------------------------------------------------------------------
	// Running an HTTP server on the SAME port as the libp2p listeners leads
	// to 400 Bad Request responses because the websocket transport's upgrade
	// handler rejects non-websocket traffic. To avoid this conflict, we expose
	// the discovery API on a **separate** HTTP port. By default this is 8080
	// or you can override with HTTP_PORT env-var.

	// Optional internal HTTP peer list API (useful for local dev). Only started
	// when ENABLE_INTERNAL_HTTP="1" (default "0" to prevent Cloud Run port clashes).
	if os.Getenv("ENABLE_INTERNAL_HTTP") == "1" {
		httpPort := 8080
		if hpStr := os.Getenv("HTTP_PORT"); hpStr != "" {
			if hp, err := strconv.Atoi(hpStr); err == nil {
				httpPort = hp
			}
		}

		// Register handlers on the default mux.
		http.HandleFunc("/peers", func(w http.ResponseWriter, r *http.Request) {
			registeredPeersMutex.Lock()
			defer registeredPeersMutex.Unlock()
			w.Header().Set("Content-Type", "application/json")
			if err := json.NewEncoder(w).Encode(registeredPeers); err != nil {
				http.Error(w, err.Error(), http.StatusInternalServerError)
				return
			}
		})

		http.HandleFunc("/peers/", func(w http.ResponseWriter, r *http.Request) {
			if r.Method != http.MethodDelete {
				http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
				return
			}
			idStr := strings.TrimPrefix(r.URL.Path, "/peers/")
			pid, err := peer.Decode(idStr)
			if err != nil {
				http.Error(w, "Invalid peer ID", http.StatusBadRequest)
				return
			}
			registeredPeersMutex.Lock()
			delete(registeredPeers, pid)
			registeredPeersMutex.Unlock()
			// Propagate deletion to peer discovery service if configured.
			if peerAPI := os.Getenv("PEER_DISCOVERY_URL"); peerAPI != "" {
				req, _ := http.NewRequest(http.MethodDelete, fmt.Sprintf("%s/peers/%s", peerAPI, pid.String()), nil)
				if _, err := http.DefaultClient.Do(req); err != nil {
					fmt.Printf("Rendezvous: Failed to propagate delete to discovery API: %v\n", err)
				}
			}
			w.WriteHeader(http.StatusNoContent)
			fmt.Printf("Rendezvous: Peer %s deleted via API\n", pid)
		})

		// Start the HTTP server in a goroutine so it doesn't block.
		go func() {
			addr := fmt.Sprintf(":%d", httpPort)
			fmt.Printf("Rendezvous: INTERNAL HTTP peer API listening on %s (endpoints: /peers, /peers/{id})\n", addr)
			if err := http.ListenAndServe(addr, nil); err != nil {
				fmt.Fprintf(os.Stderr, "Rendezvous HTTP server error: %v\n", err)
			}
		}()
	}

	// TODO: Implement rendezvous logic here.
	// For now, the service will just start, print its addresses, and wait for a signal.

	fmt.Println("Rendezvous service is running. Press Ctrl+C to stop.")

	// Wait for a SIGINT (Ctrl+C) or SIGTERM signal to gracefully shutdown.
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	<-ch
	fmt.Println("\nReceived signal, shutting down...")

	if err := h.Close(); err != nil {
		fmt.Fprintf(os.Stderr, "Error closing host: %v\n", err)
	}
	fmt.Println("Rendezvous service stopped.")
}

// getPeerAddr is a utility function that can be moved to a common package later.
func getPeerAddr(p host.Host) (ma.Multiaddr, error) {
	addrs := p.Addrs()
	if len(addrs) == 0 {
		return nil, fmt.Errorf("host has no listen addresses")
	}
	// Prefer non-loopback, public addresses if available, but for now, just pick the first one.
	// More sophisticated logic might be needed for NAT traversal.
	// Example: /ip4/192.168.1.23/tcp/4001/p2p/Qm... or /ip4/0.0.0.0/tcp/4001/p2p/Qm... which resolves to all interfaces.
	// We need to append /p2p/<peerID> to the address.
	fullAddr, err := ma.NewMultiaddr(fmt.Sprintf("%s/p2p/%s", addrs[0].String(), p.ID().String()))
	if err != nil {
		return nil, fmt.Errorf("failed to create full multiaddr: %w", err)
	}
	return fullAddr, nil
}
</file>

<file path="webdemo/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>libp2p Hole Punch Chat</title>
  <style>
    body { font-family: sans-serif; max-width: 700px; margin: auto; }
    textarea { width: 100%; height: 200px; }
  </style>
</head>
<body>
  <h1>libp2p Hole Punch Chat</h1>
  <label>Rendezvous multiaddr:
    <input id="rv" style="width:90%" placeholder="/ip4/1.2.3.4/tcp/40001/ws/p2p/..." />
  </label>
  <button id="connect">Connect</button>
  <div id="status"></div>
  <textarea id="log" readonly></textarea><br>
  <input id="msg" style="width:80%" placeholder="type a message" />
  <button id="send" disabled>Send</button>

<script type="module">
import { createLibp2p } from 'https://unpkg.com/libp2p@0.46.6/dist/index.min.js?module'
import { webSockets } from 'https://unpkg.com/@libp2p/websockets@0.17.0/dist/index.min.js?module'
import { webRTC } from 'https://unpkg.com/@libp2p/webrtc@0.17.0/dist/index.min.js?module'
import { noise } from 'https://unpkg.com/@chainsafe/libp2p-noise@11.0.0/dist/index.min.js?module'
import { mplex } from 'https://unpkg.com/@libp2p/mplex@0.16.0/dist/index.min.js?module'
import { multiaddr } from 'https://unpkg.com/@multiformats/multiaddr@11.1.0/dist/index.min.js?module'

let node
let conn
const status = document.getElementById('status')
const logBox = document.getElementById('log')

function log (msg) {
  logBox.value += msg + '\n'
  logBox.scrollTop = logBox.scrollHeight
}

document.getElementById('connect').onclick = async () => {
  const rv = document.getElementById('rv').value.trim()
  if (!rv) return
  status.textContent = 'starting libp2p...'
  node = await createLibp2p({
    transports: [webSockets(), webRTC()],
    streamMuxers: [mplex()],
    connectionEncryption: [noise()]
  })
  await node.start()
  status.textContent = `peer id: ${node.peerId.toString()}`
  log('node started with id ' + node.peerId.toString())

  node.handle('/chat/1.0.0', async ({ stream }) => {
    for await (const chunk of stream.source) {
      log('peer: ' + new TextDecoder().decode(chunk))
    }
  })

  const ma = multiaddr(rv)
  const reg = await node.dialProtocol(ma, '/holepunch/rendezvous/1.0.0')
  // send empty payload just to trigger ACK
  await reg.sink((async function * () { yield new Uint8Array() })())
  await reg.source.getReader().read()
  reg.close?.()

  const ls = await node.dialProtocol(ma, '/holepunch/list/1.0.0')
  const { value } = await ls.source.getReader().read()
  const peers = new TextDecoder().decode(value).trim().split('\n').filter(Boolean)
  if (peers.length) {
    const peerMa = multiaddr(peers[0])
    conn = await node.dialProtocol(peerMa, '/chat/1.0.0')
    log('connected to peer ' + peers[0])
  } else {
    log('no peers found; waiting for another peer to connect')
  }
  ls.close?.()
  document.getElementById('send').disabled = false
}

document.getElementById('send').onclick = async () => {
  if (!conn) return
  const msg = document.getElementById('msg').value
  document.getElementById('msg').value = ''
  log('me: ' + msg)
  await conn.sink((async function * () { yield new TextEncoder().encode(msg) })())
}
</script>
</body>
</html>
</file>

<file path="worker/.gitkeep">

</file>

<file path="worker/build_test.go">
package main

import (
    "os/exec"
    "testing"
)

func TestBinaryBuild(t *testing.T) {
    cmd := exec.Command("go", "build", "-o", "build-test-bin", ".")
    if out, err := cmd.CombinedOutput(); err != nil {
        t.Fatalf("go build failed: %v\n%s", err, string(out))
    }
}
</file>

<file path="worker/Dockerfile">
# --- Build stage ---
FROM --platform=$BUILDPLATFORM golang:1.24.3-alpine AS builder
RUN apk add --no-cache git
WORKDIR /app
COPY . ./
RUN go mod tidy && go mod download && \
    CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -trimpath -o worker .

# --- Runtime stage ---
FROM gcr.io/distroless/static-debian11
WORKDIR /app
COPY --from=builder /app/worker .
EXPOSE 8080
ENTRYPOINT ["/app/worker"]
</file>

<file path="worker/go.mod">
module github.com/yourusername/worker

go 1.24.3

require (
	github.com/libp2p/go-libp2p v0.41.1
	github.com/multiformats/go-multiaddr v0.15.0
	github.com/stretchr/testify v1.10.0
)

require (
	github.com/benbjohnson/clock v1.3.5 // indirect
	github.com/beorn7/perks v1.0.1 // indirect
	github.com/cespare/xxhash/v2 v2.3.0 // indirect
	github.com/containerd/cgroups v1.1.0 // indirect
	github.com/coreos/go-systemd/v22 v22.5.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/davidlazar/go-crypto v0.0.0-20200604182044-b73af7476f6c // indirect
	github.com/decred/dcrd/dcrec/secp256k1/v4 v4.4.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/elastic/gosigar v0.14.3 // indirect
	github.com/flynn/noise v1.1.0 // indirect
	github.com/francoispqt/gojay v1.2.13 // indirect
	github.com/go-task/slim-sprig/v3 v3.0.0 // indirect
	github.com/godbus/dbus/v5 v5.1.0 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/gopacket v1.1.19 // indirect
	github.com/google/pprof v0.0.0-20250208200701-d0013a598941 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.3 // indirect
	github.com/huin/goupnp v1.3.0 // indirect
	github.com/ipfs/go-cid v0.5.0 // indirect
	github.com/ipfs/go-log/v2 v2.5.1 // indirect
	github.com/jackpal/go-nat-pmp v1.0.2 // indirect
	github.com/jbenet/go-temp-err-catcher v0.1.0 // indirect
	github.com/klauspost/compress v1.18.0 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/koron/go-ssdp v0.0.5 // indirect
	github.com/libp2p/go-buffer-pool v0.1.0 // indirect
	github.com/libp2p/go-flow-metrics v0.2.0 // indirect
	github.com/libp2p/go-libp2p-asn-util v0.4.1 // indirect
	github.com/libp2p/go-msgio v0.3.0 // indirect
	github.com/libp2p/go-netroute v0.2.2 // indirect
	github.com/libp2p/go-reuseport v0.4.0 // indirect
	github.com/libp2p/go-yamux/v5 v5.0.0 // indirect
	github.com/marten-seemann/tcp v0.0.0-20210406111302-dfbc87cc63fd // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/miekg/dns v1.1.63 // indirect
	github.com/mikioh/tcpinfo v0.0.0-20190314235526-30a79bb1804b // indirect
	github.com/mikioh/tcpopt v0.0.0-20190314235656-172688c1accc // indirect
	github.com/minio/sha256-simd v1.0.1 // indirect
	github.com/mr-tron/base58 v1.2.0 // indirect
	github.com/multiformats/go-base32 v0.1.0 // indirect
	github.com/multiformats/go-base36 v0.2.0 // indirect
	github.com/multiformats/go-multiaddr-dns v0.4.1 // indirect
	github.com/multiformats/go-multiaddr-fmt v0.1.0 // indirect
	github.com/multiformats/go-multibase v0.2.0 // indirect
	github.com/multiformats/go-multicodec v0.9.0 // indirect
	github.com/multiformats/go-multihash v0.2.3 // indirect
	github.com/multiformats/go-multistream v0.6.0 // indirect
	github.com/multiformats/go-varint v0.0.7 // indirect
	github.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822 // indirect
	github.com/onsi/ginkgo/v2 v2.22.2 // indirect
	github.com/opencontainers/runtime-spec v1.2.0 // indirect
	github.com/pbnjay/memory v0.0.0-20210728143218-7b4eea64cf58 // indirect
	github.com/pion/datachannel v1.5.10 // indirect
	github.com/pion/dtls/v2 v2.2.12 // indirect
	github.com/pion/dtls/v3 v3.0.4 // indirect
	github.com/pion/ice/v4 v4.0.8 // indirect
	github.com/pion/interceptor v0.1.37 // indirect
	github.com/pion/logging v0.2.3 // indirect
	github.com/pion/mdns/v2 v2.0.7 // indirect
	github.com/pion/randutil v0.1.0 // indirect
	github.com/pion/rtcp v1.2.15 // indirect
	github.com/pion/rtp v1.8.11 // indirect
	github.com/pion/sctp v1.8.37 // indirect
	github.com/pion/sdp/v3 v3.0.10 // indirect
	github.com/pion/srtp/v3 v3.0.4 // indirect
	github.com/pion/stun v0.6.1 // indirect
	github.com/pion/stun/v3 v3.0.0 // indirect
	github.com/pion/transport/v2 v2.2.10 // indirect
	github.com/pion/transport/v3 v3.0.7 // indirect
	github.com/pion/turn/v4 v4.0.0 // indirect
	github.com/pion/webrtc/v4 v4.0.10 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/prometheus/client_golang v1.21.1 // indirect
	github.com/prometheus/client_model v0.6.1 // indirect
	github.com/prometheus/common v0.62.0 // indirect
	github.com/prometheus/procfs v0.15.1 // indirect
	github.com/quic-go/qpack v0.5.1 // indirect
	github.com/quic-go/quic-go v0.50.1 // indirect
	github.com/quic-go/webtransport-go v0.8.1-0.20241018022711-4ac2c9250e66 // indirect
	github.com/raulk/go-watchdog v1.3.0 // indirect
	github.com/spaolacci/murmur3 v1.1.0 // indirect
	github.com/wlynxg/anet v0.0.5 // indirect
	go.uber.org/dig v1.18.0 // indirect
	go.uber.org/fx v1.23.0 // indirect
	go.uber.org/mock v0.5.0 // indirect
	go.uber.org/multierr v1.11.0 // indirect
	go.uber.org/zap v1.27.0 // indirect
	golang.org/x/crypto v0.35.0 // indirect
	golang.org/x/exp v0.0.0-20250218142911-aa4b98e5adaa // indirect
	golang.org/x/mod v0.23.0 // indirect
	golang.org/x/net v0.35.0 // indirect
	golang.org/x/sync v0.11.0 // indirect
	golang.org/x/sys v0.30.0 // indirect
	golang.org/x/text v0.22.0 // indirect
	golang.org/x/tools v0.30.0 // indirect
	google.golang.org/protobuf v1.36.5 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
	lukechampine.com/blake3 v1.4.0 // indirect
)
</file>

<file path="worker/host_test.go">
package main

import (
    "context"
    "strings"
    "testing"
)

// TestCreateWorkerHostIncludesWebsocket ensures worker host exposes /ws address.
func TestCreateWorkerHostIncludesWebsocket(t *testing.T) {
    ctx := context.Background()
    h, err := createWorkerHost(ctx, 0)
    if err != nil {
        t.Fatalf("createWorkerHost error: %v", err)
    }
    defer h.Close()

    hasWS := false
    for _, a := range h.Addrs() {
        if strings.Contains(a.String(), "/ws") {
            hasWS = true
            break
        }
    }
    if !hasWS {
        t.Fatalf("expected /ws address in %v", h.Addrs())
    }
}
</file>

<file path="worker/main_test.go">
package main

import (
	"context"
	"fmt"
	"io"
	"strings"
	"sync"
	"testing"
	"time"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/network"
	"github.com/libp2p/go-libp2p/core/peer"
	ws "github.com/libp2p/go-libp2p/p2p/transport/websocket"
	ma "github.com/multiformats/go-multiaddr"
	"github.com/stretchr/testify/require"
)

// Store for registered peers in tests.
var (
	testRegisteredPeers      = make(map[peer.ID]ma.Multiaddr)
	testRegisteredPeersMutex = &sync.Mutex{}
)

// TestWorkerServiceRuns remains as placeholder if desired (removed duplicate tests)

// simpleRegistrationHandlerForTest is used in tests to simulate rendezvous ACK.
// It also now registers the peer to testRegisteredPeers for the listHandler to use.
func simpleRegistrationHandlerForTest(s network.Stream) {
	remotePeerID := s.Conn().RemotePeer()
	remoteAddr := s.Conn().RemoteMultiaddr()

	testRegisteredPeersMutex.Lock()
	testRegisteredPeers[remotePeerID] = remoteAddr
	testRegisteredPeersMutex.Unlock()

	// Write ACK immediately so the client isn't blocked waiting.
	_, _ = s.Write([]byte("ACK"))
	// Drain any incoming data (optional) then close.
	io.Copy(io.Discard, s)
	_ = s.Close()
}

// listHandler for tests, mimics the rendezvous listHandler.
func listHandler(s network.Stream) {
	defer s.Close()
	requester := s.Conn().RemotePeer()
	testRegisteredPeersMutex.Lock()
	defer testRegisteredPeersMutex.Unlock()

	var peerAddrs []string
	for pid, addr := range testRegisteredPeers {
		if pid == requester {
			continue
		}
		fullAddrStr := fmt.Sprintf("%s/p2p/%s", addr.String(), pid.String())
		peerAddrs = append(peerAddrs, fullAddrStr)
	}
	_, _ = s.Write([]byte(strings.Join(peerAddrs, "\n") + "\n"))
}

// TestWorkerConnectsAndRegisters ensures worker connects to rendezvous and gets ACK.
func TestWorkerConnectsAndRegisters(t *testing.T) {
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Create rendezvous host using createWorkerHost for simplicity
	rendezvousHost, err := createWorkerHost(ctx, 0)
	require.NoError(t, err)
	defer rendezvousHost.Close()

	// set handler
	rendezvousHost.SetStreamHandler(ProtocolIDForRegistration, simpleRegistrationHandlerForTest)

	// Build multiaddr for rendezvous host (use first address)
	require.NotEmpty(t, rendezvousHost.Addrs())
	rendezvousMaddrStr := fmt.Sprintf("%s/p2p/%s", rendezvousHost.Addrs()[0], rendezvousHost.ID())

	// Create worker host
	workerHost, err := createWorkerHost(ctx, 0)
	require.NoError(t, err)
	defer workerHost.Close()

	// Call connectAndRegisterWithRendezvous
	err = connectAndRegisterWithRendezvous(ctx, workerHost, rendezvousMaddrStr)
	require.NoError(t, err)
}

// TestDiscoverPeersAndDial uses the list protocol to connect two workers via the rendezvous host.
func TestDiscoverPeersAndDial(t *testing.T) {
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()

	// Clear the shared map for this test run
	testRegisteredPeersMutex.Lock()
	clear(testRegisteredPeers)
	testRegisteredPeersMutex.Unlock()

	rvHost, err := createWorkerHost(ctx, 0)
	require.NoError(t, err)
	defer rvHost.Close()
	rvHost.SetStreamHandler(ProtocolIDForRegistration, simpleRegistrationHandlerForTest)
	rvHost.SetStreamHandler(ProtocolIDForPeerList, listHandler)

	rvHostAddrInfo := peer.AddrInfo{
		ID:    rvHost.ID(),
		Addrs: rvHost.Addrs(),
	}

	// Create w1
	w1, err := libp2p.New(
		libp2p.ListenAddrStrings("/ip4/0.0.0.0/tcp/0", "/ip4/0.0.0.0/tcp/0/ws"),
		libp2p.Transport(ws.New),
		libp2p.EnableHolePunching(),
		libp2p.EnableAutoRelayWithStaticRelays([]peer.AddrInfo{rvHostAddrInfo}),
		libp2p.NATPortMap(),
	)
	require.NoError(t, err)
	defer w1.Close()

	// Create w2
	w2, err := libp2p.New(
		libp2p.ListenAddrStrings("/ip4/0.0.0.0/tcp/0", "/ip4/0.0.0.0/tcp/0/ws"),
		libp2p.Transport(ws.New),
		libp2p.EnableHolePunching(),
		libp2p.EnableAutoRelayWithStaticRelays([]peer.AddrInfo{rvHostAddrInfo}),
		libp2p.NATPortMap(),
	)
	require.NoError(t, err)
	defer w2.Close()

	addrStr := fmt.Sprintf("%s/p2p/%s", rvHost.Addrs()[0], rvHost.ID())

	// w1 registers. simpleRegistrationHandlerForTest will store its s.Conn().RemoteMultiaddr().
	require.NoError(t, connectAndRegisterWithRendezvous(ctx, w1, addrStr))
	// w2 registers. simpleRegistrationHandlerForTest will store its s.Conn().RemoteMultiaddr().
	require.NoError(t, connectAndRegisterWithRendezvous(ctx, w2, addrStr))

	// Now, OVERRIDE w2's entry in testRegisteredPeers with its actual listen address
	// so that listHandler provides this correct address to w1.
	var w2ListenAddrToUse ma.Multiaddr
	for _, addr := range w2.Addrs() {
		if strings.Contains(addr.String(), "/ip4/") && !strings.Contains(addr.String(), "127.0.0.1") {
			w2ListenAddrToUse = addr
			break
		}
	}
	if w2ListenAddrToUse == nil {
		for _, addr := range w2.Addrs() {
			if strings.Contains(addr.String(), "/ip4/") {
				w2ListenAddrToUse = addr
				break
			}
		}
	}
	require.NotNil(t, w2ListenAddrToUse, "w2 has no suitable IPv4 listen address")

	testRegisteredPeersMutex.Lock()
	origW2Addr := testRegisteredPeers[w2.ID()] // The one from simpleRegistrationHandlerForTest
	testRegisteredPeers[w2.ID()] = w2ListenAddrToUse
	testRegisteredPeersMutex.Unlock()
	t.Logf("Overrode w2 address for discovery. Was: %s, Now: %s", origW2Addr, w2ListenAddrToUse)

	peers, err := discoverPeersViaListProtocol(ctx, w1, addrStr)
	require.NoError(t, err)
	require.GreaterOrEqual(t, len(peers), 1, "Should discover at least w2")

	var w2Info peer.AddrInfo
	foundW2 := false
	for _, p := range peers {
		if p.ID == w2.ID() {
			w2Info = p
			foundW2 = true
			break
		}
	}
	require.True(t, foundW2, "w2 not found in discovered peers")
	require.NotEqual(t, peer.ID(""), w2Info.ID, "w2Info should be populated")
	// Check that the address for w2 in w2Info is indeed the listen address we overrode with.
	require.Len(t, w2Info.Addrs, 1, "w2Info should have one address from our map")
	require.Equal(t, w2ListenAddrToUse.String(), w2Info.Addrs[0].String(), "w2Info address mismatch")

	t.Logf("w1 (%s) attempting to connect to w2 (%s) with AddrInfo: %v", w1.ID(), w2.ID(), w2Info)
	err = w1.Connect(ctx, w2Info)
	if err != nil {
		t.Logf("w1 addrs: %v", w1.Addrs())
		t.Logf("w2 addrs: %v", w2.Addrs())
		t.Logf("w2Info used for connect: %v", w2Info.Addrs)
	}
	require.NoError(t, err)
}
</file>

<file path="worker/main.go">
package main

import (
	"context"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"

	"github.com/libp2p/go-libp2p"
	"github.com/libp2p/go-libp2p/core/host"
	"github.com/libp2p/go-libp2p/core/peer"
	tptquic "github.com/libp2p/go-libp2p/p2p/transport/quic"
	tptws "github.com/libp2p/go-libp2p/p2p/transport/websocket"
	ma "github.com/multiformats/go-multiaddr"
)

// ProtocolIDForRegistration is the libp2p protocol ID used by workers to register with the rendezvous service.
// This should match the one defined in the rendezvous service.
const ProtocolIDForRegistration = "/holepunch/rendezvous/1.0.0"

// ProtocolIDForPeerList matches the rendezvous service's peer list protocol.
const ProtocolIDForPeerList = "/holepunch/list/1.0.0"

// connectAndRegisterWithRendezvous connects the worker host to the rendezvous service at the given
// multiaddress string and performs a simple registration handshake (expecting an "ACK" response).
func connectAndRegisterWithRendezvous(ctx context.Context, h host.Host, rendezvousAddrStr string) error {
	// Parse multiaddr
	rendezvousMaddr, err := ma.NewMultiaddr(rendezvousAddrStr)
	if err != nil {
		return fmt.Errorf("invalid rendezvous multiaddr: %w", err)
	}

	addrInfo, err := peer.AddrInfoFromP2pAddr(rendezvousMaddr)
	if err != nil {
		return fmt.Errorf("failed to extract AddrInfo: %w", err)
	}

	// Connect
	if err := h.Connect(ctx, *addrInfo); err != nil {
		return fmt.Errorf("failed to connect to rendezvous: %w", err)
	}

	// Open stream
	stream, err := h.NewStream(ctx, addrInfo.ID, ProtocolIDForRegistration)
	if err != nil {
		return fmt.Errorf("failed to open registration stream: %w", err)
	}
	defer stream.Close()

	// Optionally send payload (not required)
	//_, _ = stream.Write([]byte("REGISTER"))

	// Wait for ACK (blocking read up to 3 bytes)
	ack := make([]byte, 3)
	if _, err := io.ReadFull(stream, ack); err != nil {
		return fmt.Errorf("failed to read ACK from rendezvous: %w", err)
	}
	if string(ack) != "ACK" {
		return fmt.Errorf("unexpected ACK response: %s", string(ack))
	}
	return nil
}

// discoverPeersViaListProtocol queries the rendezvous service for a list of peers
// using the libp2p peer list protocol.
func discoverPeersViaListProtocol(ctx context.Context, h host.Host, rendezvousAddrStr string) ([]peer.AddrInfo, error) {
	rendezvousMaddr, err := ma.NewMultiaddr(rendezvousAddrStr)
	if err != nil {
		return nil, fmt.Errorf("invalid rendezvous multiaddr: %w", err)
	}
	addrInfo, err := peer.AddrInfoFromP2pAddr(rendezvousMaddr)
	if err != nil {
		return nil, fmt.Errorf("failed to extract AddrInfo: %w", err)
	}

	s, err := h.NewStream(ctx, addrInfo.ID, ProtocolIDForPeerList)
	if err != nil {
		return nil, fmt.Errorf("failed to open list stream: %w", err)
	}
	defer s.Close()

	data, err := io.ReadAll(s)
	if err != nil {
		return nil, fmt.Errorf("failed reading list response: %w", err)
	}

	var peers []peer.AddrInfo
	lines := strings.Split(strings.TrimSpace(string(data)), "\n")
	for _, line := range lines {
		if line == "" {
			continue
		}
		maddr, err := ma.NewMultiaddr(line)
		if err != nil {
			continue
		}
		info, err := peer.AddrInfoFromP2pAddr(maddr)
		if err != nil {
			continue
		}
		peers = append(peers, *info)
	}
	return peers, nil
}

// createWorkerHost creates a new libp2p host, typically configured as a client.
// listenPort < 0 means no specific listen address by default.
// listenPort 0 means listen on a random OS-chosen port.
// listenPort > 0 means listen on that specific port.
func createWorkerHost(ctx context.Context, listenPort int) (host.Host, error) {
	var listenAddrs []string
	if listenPort >= 0 { // Use >=0 to allow explicit port 0 for random OS-chosen port, or a specific port
		tcpAddr := fmt.Sprintf("/ip4/0.0.0.0/tcp/%d", listenPort)
		wsAddr := fmt.Sprintf("/ip4/0.0.0.0/tcp/%d/ws", listenPort)
		quicAddr := fmt.Sprintf("/ip4/0.0.0.0/udp/%d/quic-v1", listenPort)
		listenAddrs = append(listenAddrs, tcpAddr, wsAddr, quicAddr)
	}

	h, err := libp2p.New(
		libp2p.ListenAddrStrings(listenAddrs...),
		libp2p.Transport(tptws.New),
		libp2p.Transport(tptquic.NewTransport),
		libp2p.EnableHolePunching(),
		libp2p.NATPortMap(),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create libp2p host: %w", err)
	}
	return h, nil
}

func main() {
	// Command-line flags
	rendezvousAddrStr := flag.String("rendezvous", "", "Rendezvous server multiaddress (can alternatively be provided via RENDEZVOUS_MULTIADDR or RENDEZVOUS_ADDR env vars)")
	listenPort := flag.Int("listen-port", 0, "Port for the worker to listen on (0 for random, -1 for none)")
	flag.Parse()

	// ------------------------------------------------------------
	// Fallback to environment variables if flag not supplied.
	// This makes Cloud Run deployments simpler because you can now
	// pass the multiaddr with `--set-env-vars RENDEZVOUS_MULTIADDR=...`
	// instead of supplying container args.
	// ------------------------------------------------------------
	if *rendezvousAddrStr == "" {
		if envAddr := os.Getenv("RENDEZVOUS_MULTIADDR"); envAddr != "" {
			*rendezvousAddrStr = envAddr
		} else if envAddr2 := os.Getenv("RENDEZVOUS_ADDR"); envAddr2 != "" {
			*rendezvousAddrStr = envAddr2
		}
	}

	fmt.Println("Worker service starting...")
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	h, err := createWorkerHost(ctx, *listenPort)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating worker host: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Worker host created with ID: %s\n", h.ID().String())
	if len(h.Addrs()) > 0 {
		fmt.Println("Worker listening on addresses:")
		for _, addr := range h.Addrs() {
			fmt.Printf("  %s/p2p/%s\n", addr, h.ID().String())
		}
	} else {
		fmt.Println("Worker host not configured to listen on specific addresses.")
	}

	if *rendezvousAddrStr == "" {
		fmt.Println("No rendezvous server address provided. Worker will idle.")
		// TODO: In a real scenario, might exit or have other behavior
	} else {
		fmt.Printf("Rendezvous server: %s\n", *rendezvousAddrStr)

		err = connectAndRegisterWithRendezvous(ctx, h, *rendezvousAddrStr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error connecting to rendezvous:%v\n", err)
		} else {
			fmt.Println("Worker successfully registered with rendezvous.")

			peers, err := discoverPeersViaListProtocol(ctx, h, *rendezvousAddrStr)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Peer discovery error: %v\n", err)
			} else {
				for _, info := range peers {
					if info.ID == h.ID() {
						continue
					}
					if err := h.Connect(ctx, info); err == nil {
						fmt.Printf("Connected to peer %s\n", info.ID)
					} else {
						fmt.Printf("Failed to connect to peer %s: %v\n", info.ID, err)
					}
				}
			}
		}
	}

	// Start health server for Cloud Run
	startHealthServer()

	fmt.Println("Worker service is running. Press Ctrl+C to stop.")
	ch := make(chan os.Signal, 1)
	signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
	<-ch
	fmt.Println("\nReceived signal, shutting down worker...")

	if err := h.Close(); err != nil {
		fmt.Fprintf(os.Stderr, "Error closing worker host: %v\n", err)
	}
	fmt.Println("Worker service stopped.")
}

// startHealthServer launches a tiny HTTP server that always returns 200 OK.
// Cloud Run pings this port (from $PORT env, default 8080) to determine readiness.
func startHealthServer() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	go func() {
		http.HandleFunc("/", func(w http.ResponseWriter, _ *http.Request) {
			w.WriteHeader(http.StatusOK)
			_, _ = w.Write([]byte("OK"))
		})
		if err := http.ListenAndServe(":"+port, nil); err != nil {
			fmt.Fprintf(os.Stderr, "health server error: %v\n", err)
		}
	}()
}
</file>

<file path="deploy_cloud_run.sh">
#!/usr/bin/env bash
# Build & deploy a go-libp2p service (rendezvous or worker) to Cloud Run using Cloud Build.
# Usage:
#   ./deploy_cloud_run.sh <service> <project_id> <region> [tag] [--deploy-only] [<additional gcloud args>]
# Example:
#   ./deploy_cloud_run.sh rendezvous my-gcp-project us-central1 v1
set -euo pipefail

# -----------------------------------------------------------------------------
# Usage
#   ./deploy_cloud_run.sh <service> <project_id> <region> [tag] [--deploy-only] [<additional gcloud args>]
#
# Example (build & deploy):
#   ./deploy_cloud_run.sh rendezvous my-gcp-project us-central1 v1
#
# Example (deploy-only, skip build):
#   ./deploy_cloud_run.sh worker my-gcp-project us-central1 v1 --deploy-only --set-env-vars "RENDEZVOUS_SERVICE_URL=https://..."
# -----------------------------------------------------------------------------

if [[ $# -lt 3 ]]; then
  echo "usage: $0 <rendezvous|worker> <PROJECT_ID> <REGION> [TAG] [--deploy-only] [<extra gcloud run deploy args>]" >&2
  exit 1
fi

# Required positional args
SERVICE=$1; shift
PROJECT=$1; shift
REGION=$1; shift

# Optional tag (defaults to latest) â€“ only treat next arg as TAG if it does NOT start with '--'
if [[ $# -gt 0 && $1 != --* ]]; then
  TAG=$1
  shift
else
  TAG="latest"
fi

# Flags / extra args processing
DEPLOY_ONLY=false
EXTRA_ARGS=()
while (( "$#" )); do
  case "$1" in
    --deploy-only)
      DEPLOY_ONLY=true
      shift
      ;;
    *)
      EXTRA_ARGS+=("$1")
      shift
      ;;
  esac
done

ROOT_DIR="$(cd "$(dirname "$0")"; pwd)"
SERVICE_DIR="$ROOT_DIR/${SERVICE}"
IMAGE="${REGION}-docker.pkg.dev/${PROJECT}/${SERVICE}-repo/${SERVICE}:${TAG}"

if [[ ! -d "$SERVICE_DIR" ]]; then
  echo "Unknown service dir $SERVICE_DIR" >&2; exit 1
fi

# -----------------------------------------------------------------------------
# Build & push image (unless --deploy-only was supplied)
# -----------------------------------------------------------------------------
if [[ "$DEPLOY_ONLY" == false ]]; then
  echo "Building & pushing image $IMAGE with docker buildx ..."

  # ensure repo exists
  gcloud artifacts repositories describe "${SERVICE}-repo" \
       --project "$PROJECT" --location "$REGION" >/dev/null 2>&1 || \
    gcloud artifacts repositories create "${SERVICE}-repo" \
       --repository-format=docker --location "$REGION" --description="repo for $SERVICE"

  # configure docker to push to Artifact Registry
  gcloud auth configure-docker "${REGION}-docker.pkg.dev" --quiet

  # build & push (linux/amd64)
  docker buildx build --no-cache --pull --platform linux/amd64 -t "$IMAGE" --push "$SERVICE_DIR"
else
  echo "Skipping image build & push (deploy-only). Using existing image $IMAGE"
fi

# -----------------------------------------------------------------------------
# Deploy to Cloud Run
# -----------------------------------------------------------------------------

echo "Deploying to Cloud Run ($SERVICE)..."
gcloud run deploy "$SERVICE" \
  --project="$PROJECT" \
  --region="$REGION" \
  --image="$IMAGE" \
  --platform=managed \
  --allow-unauthenticated \
  --session-affinity \
  --max-instances=2 \
  "${EXTRA_ARGS[@]}"

echo "Done. Get URL with: gcloud run services describe $SERVICE --platform managed --region $REGION --format='value(status.url)'"
</file>

<file path="deploy_demo_cloud_run.sh">
#!/usr/bin/env bash
# High-level helper: build & deploy rendezvous + worker for the demo (default networking).
# It builds both images with Cloud Build, deploys rendezvous, grabs its URL,
# then deploys the worker with RENDEZVOUS_SERVICE_URL set.
#
# Usage: ./deploy_demo_cloud_run.sh <PROJECT_ID> <REGION> [TAG] [NUM_WORKERS]
set -euo pipefail

# -----------------------------------------------------------------------------
# Args & sane defaults: if PROJECT_ID or REGION not supplied, fall back to the
# current gcloud configuration. This lets you simply run ./deploy_demo_cloud_run.sh
# when you already have a project/region set with `gcloud config set project ...`.
# -----------------------------------------------------------------------------
if [[ $# -lt 1 ]]; then
  PROJECT_ID=$(gcloud config get-value project 2>/dev/null || true)
else
  PROJECT_ID=$1; shift
fi

if [[ -z "$PROJECT_ID" ]]; then
  echo "ERROR: PROJECT_ID not supplied and no default configured (gcloud config get-value project)." >&2
  echo "Usage: $0 <PROJECT_ID> [REGION] [TAG] [NUM_WORKERS]" >&2
  exit 1
fi

if [[ $# -lt 1 ]]; then
  REGION=$(gcloud config get-value run/region 2>/dev/null || echo "us-central1")
else
  REGION=$1; shift
fi

# Optional third positional arg is TAG (container image tag).
# Optional fourth positional arg is NUM_WORKERS (default 1).
TAG=${1:-demo}
shift || true

# If the next arg looks like an integer, treat it as NUM_WORKERS, else default 1.
if [[ ${1:-} =~ ^[0-9]+$ ]]; then
  NUM_WORKERS=$1; shift
else
  NUM_WORKERS=3
fi

echo "Will start $NUM_WORKERS worker instance(s)."

ROOT_DIR="$(cd "$(dirname "$0")"; pwd)"

# Build & deploy peerapi first (build + deploy)
"$ROOT_DIR/deploy_cloud_run.sh" peerapi "$PROJECT_ID" "$REGION" "$TAG" --min-instances=1

# Capture peerapi URL (used by both rendezvous & workers)
PEERAPI_URL=$(gcloud run services describe peerapi --project "$PROJECT_ID" --region "$REGION" --platform managed --format='value(status.url)')
if [[ -z "$PEERAPI_URL" ]]; then echo "Failed to obtain peerapi URL" >&2; exit 1; fi
echo "peerapi URL: $PEERAPI_URL"

# Build & deploy rendezvous (with PEER_DISCOVERY_URL)
"$ROOT_DIR/deploy_cloud_run.sh" rendezvous "$PROJECT_ID" "$REGION" "$TAG" --min-instances=1 --set-env-vars "PEER_DISCOVERY_URL=$PEERAPI_URL"

# -----------------------------------------------------------------------------
# Grab the service URL (useful for browser access / debugging)
# -----------------------------------------------------------------------------
# Fetch latest ready revision name to filter logs precisely
LATEST_REV=$(gcloud run services describe rendezvous \
  --project "$PROJECT_ID" --region "$REGION" --platform managed \
  --format='value(status.latestReadyRevisionName)')

RV_URL=$(gcloud run services describe rendezvous --project "$PROJECT_ID" --region "$REGION" --platform managed --format='value(status.url)')
if [[ -z "$RV_URL" ]]; then echo "Failed to obtain rendezvous URL" >&2; exit 1; fi

echo "Rendezvous URL (HTTP): $RV_URL"

# -----------------------------------------------------------------------------
# Helper: poll Cloud Run logs until we see the host-ID line or we time out.
# -----------------------------------------------------------------------------
echo "Fetching rendezvous multiaddr from Cloud Run logs of $LATEST_REV (waiting up to 60s)..." >&2
R_V_LOG_QUERY="resource.type=cloud_run_revision AND resource.labels.service_name=rendezvous AND resource.labels.revision_name=$LATEST_REV AND textPayload:(\"Host created with ID:\")"

get_peer_id_from_logs() {
  gcloud logging read "$R_V_LOG_QUERY" \
    --project="$PROJECT_ID" --limit 20 --order=DESC \
    --format="value(textPayload)" | grep -m1 "Host created with ID:" | sed -E 's/.*Host created with ID: ([A-Za-z0-9]+).*/\1/' || true
}

PEER_ID=""
# First polling loop (Cloud Logging API)
for _ in {1..2}; do  # up to 2 minutes
  PEER_ID=$(get_peer_id_from_logs)
  [[ -n "$PEER_ID" ]] && break
  sleep 5
done

# Fallback: try the managed helper (faster ingest for recent logs)
if [[ -z "$PEER_ID" ]]; then
  get_peer_id_run_logs() {
    gcloud run services logs read rendezvous --region "$REGION" --project "$PROJECT_ID" --limit 100 --format='value(textPayload)' | \
      grep -m1 "Host created with ID:" | sed -E 's/.*Host created with ID: ([A-Za-z0-9]+).*/\1/' || true
  }
  for _ in {1..12}; do # another 30s
    PEER_ID=$(get_peer_id_run_logs)
    [[ -n "$PEER_ID" ]] && break
    sleep 5
  done
fi

# Build a wss/dns multiaddr that the worker can dial over the public HTTPS endpoint
if [[ -n "$PEER_ID" ]]; then
  HOST_NO_SCHEME=${RV_URL#https://}
  HOST_NO_SCHEME=${HOST_NO_SCHEME#http://}
  RV_MULTIADDR="/dns4/${HOST_NO_SCHEME}/tcp/443/wss/p2p/${PEER_ID}"
  echo "Constructed rendezvous multiaddr: $RV_MULTIADDR"
else
  # Fallback: attempt to harvest any multiaddr in logs (may be internal and unreachable)
  RV_MULTIADDR=$(gcloud logging read "$R_V_LOG_QUERY" --project="$PROJECT_ID" --limit 20 --order=DESC --format="value(textPayload)" | \
    grep -m1 -Eo '/ip[^ ]+/p2p/[A-Za-z0-9]+' || true)
  # Ensure /ws or /wss component is present; if the multiaddr ends with '/tcp/PORT' insert '/ws' before /p2p.
  if [[ -n "$RV_MULTIADDR" && "$RV_MULTIADDR" != *"/ws/p2p"* && "$RV_MULTIADDR" != *"/wss/p2p"* ]]; then
    RV_MULTIADDR=$(echo "$RV_MULTIADDR" | sed -E 's|(tcp/[0-9]+)/p2p|\1/ws/p2p|')
  fi
  if [[ -z "$RV_MULTIADDR" ]]; then
    echo "WARNING: Could not obtain rendezvous multiaddr." >&2
  else
    echo "Detected rendezvous multiaddr: $RV_MULTIADDR (may be unreachable if internal)"
  fi
fi

# Build & deploy worker (inject env var)

ENV_VARS=("RENDEZVOUS_SERVICE_URL=$PEERAPI_URL")
if [[ -n "$RV_MULTIADDR" ]]; then ENV_VARS+=("RENDEZVOUS_MULTIADDR=$RV_MULTIADDR"); fi

# Join env vars with comma for gcloud flag
ENV_VARS_JOINED=$(IFS=, ; echo "${ENV_VARS[*]}")

# Deploy worker service with the requested baseline instances so Cloud Run spins
# them up immediately (each worker keeps an idle HTTP listener so additional
# scaling is unlikely without min-instances).
"$ROOT_DIR/deploy_cloud_run.sh" worker "$PROJECT_ID" "$REGION" "$TAG" --set-env-vars "$ENV_VARS_JOINED" --min-instances=$NUM_WORKERS --max-instances=$NUM_WORKERS --args ""

echo "\nDemo deployed!\nRendezvous HTTP URL: $RV_URL"
</file>

<file path="Makefile">
# Simple convenience Makefile for local development

# Usage examples:
#   make rendezvous            # start rendezvous on default port 40001
#   make worker RENDEZVOUS=<multiaddr>   # start a worker pointing at the rendezvous address
#   make worker-multi N=3 RENDEZVOUS=<multiaddr>  # start N workers in background (requires GNU seq)

.PHONY: rendezvous worker worker-multi peerapi

# Build variables
RENDEZVOUS_DIR=./rendezvous
WORKER_DIR=./worker
PEERAPI_DIR=./peerapi

rendezvous:
	@echo "Starting rendezvous service..."
	@cd $(RENDEZVOUS_DIR) && go run .

worker:
ifdef RENDEZVOUS
	@echo "Starting worker (RENDEZVOUS=$(RENDEZVOUS))..."
	@cd $(WORKER_DIR) && go run . -rendezvous $(RENDEZVOUS)
else
	@echo "Please provide RENDEZVOUS=<multiaddr>, e.g. make worker RENDEZVOUS=/ip4/127.0.0.1/tcp/40001/p2p/<peerid>" && false
endif

# Spawn N workers in background; example: make worker-multi N=5 RENDEZVOUS=<addr>
worker-multi:
ifndef RENDEZVOUS
	@echo "RENDEZVOUS variable required" && false
endif
	@echo "Spawning $(N) workers..."
	@for i in $(shell seq 1 $(or ${N},1)); do \
		( cd $(WORKER_DIR) && go run . -rendezvous $(RENDEZVOUS) ) & \
	done
	@echo "Workers started in background. Use 'jobs' to list."

peerapi:
	@echo "Starting peer discovery API service..."
	@cd $(PEERAPI_DIR) && go run .
</file>

<file path="README.md">
# go-libp2p Hole-Punch POC

This directory contains two small services built with Go libp2p:

* **`rendezvous`** â€“ a central node that workers dial to announce themselves.
* **`worker`** â€“ a client node that registers with the rendezvous service.

Both packages have unit tests (`go test ./...`), and everything is wired-up for quick local runs.

## Quick start

1. **Open a terminal & start the rendezvous service**

   ```bash
   cd go-libp2p-holepunch-services
   make rendezvous     # or: go run ./rendezvous
   ```

   It prints something like

   ```
   Listening on addresses:
     /ip4/127.0.0.1/tcp/40001/p2p/12D3KooWâ€¦
   ```

2. **Copy one of the printed multi-addresses** (the whole line!)

3. **In another terminal, start a worker**

   ```bash
   cd go-libp2p-holepunch-services
   make worker RENDEZVOUS=/ip4/127.0.0.1/tcp/40001/p2p/12D3KooWâ€¦
   ```

   The worker connects, receives an `ACK`, and stays running.

4. **Spin up more workers**

   ```bash
   make worker-multi N=3 RENDEZVOUS=/ip4/.../p2p/...
   ```

You will see each registration appear in the rendezvous terminal.

## Tests

```bash
cd go-libp2p-holepunch-services/rendezvous && go test -v
cd ../worker && go test -v
```

## Features

* `/list` protocol allows workers to discover peers directly from the rendezvous service.
* Workers use libp2p's hole punching and AutoRelay to form direct or relayed connections.
  Set `LIBP2P_RELAY_BOOTSTRAP` to a relay multiaddr if you provide one.
* Containerise each service (`Dockerfile`) and deploy to Cloud Run behind Cloud NAT.

## One-command Cloud Run deploy (experimental)

If you have the Google Cloud CLI installed and already ran `gcloud auth login`, you can push
and deploy all three demo services with a single helper script:

```bash
cd go-libp2p-holepunch-services

# region and project are positional arguments
./deploy_to_cloud_run.sh us-central1 my-gcp-project
```

What the script does:

1. Build and push container images for `peerapi`, `rendezvous`, and `worker` to
   `gcr.io/<project>/go-libp2p-holepunch-demo/â€¦:latest`.
2. Deploy **peerapi** first, capture its public URL.
3. Deploy **rendezvous** with the env-var `PEER_DISCOVERY_URL=<peerapi-url>` so
   every registration is mirrored to the JSON API.
4. Ask you to copy the rendezvous node's libp2p **multi-address** from its
   startup logs (Cloud Run generates a fresh peer ID every time).  Paste it
   back to the script.
5. Deploy **worker** with both `RENDEZVOUS_MULTIADDR` *and*
   `RENDEZVOUS_SERVICE_URL` set.

After the final step Cloud Run hosts three fully-working services:

* peerapi      â†’ JSON list of peers
* rendezvous â†’ libp2p WebSocket listener (wss)
* worker      â†’ connects, registers, then fetches the peer list

You can scale out additional workers via

```bash
gcloud run jobs create worker-copy --image gcr.io/<project>/go-libp2p-holepunch-demo/worker:latest \
  --region us-central1 --tasks 5 --set-env-vars "RENDEZVOUS_MULTIADDR=â€¦,RENDEZVOUS_SERVICE_URL=<peerapi-url>" --execute-now
```

The script is a *convenience helper* â€” feel free to adjust it to your CI/CD
pipeline or replace it with Terraform. 
## Browser demo

A simple web interface lives in [`webdemo/index.html`](webdemo/index.html). Serve this directory with any static file server and open the page in two browser windows. Enter the rendezvous multiaddress printed by the service and click **Connect**. Once a second peer joins you can exchange chat messages and watch the hole punching attempts in the browser console.
</file>

</files>
